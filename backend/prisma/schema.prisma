generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// ───────────────────────── User / Person ─────────────────────────
model User {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Identity
  fullName String?
  email    String  @unique
  password String // Hashed
  avatar   String  @default("/default-avatar.png")
  bio      String?
  publicKey String? // E2EE

  // Account Status
  emailVerified    Boolean @default(false)
  role             Role    @default(user) // user, mod, admin
  isActive         Boolean @default(true)
  verificationCode String?

  // Moderation & Safety
  reportsReceivedCount Int           @default(0)
  isPermanentlyDeleted Boolean       @default(false)
  accountStatus        AccountStatus @default(ACTIVE)
  suspendedUntil       DateTime?
  suspendedReason      String?
  bannedAt             DateTime?
  bannedReason         String?
  strikeCount          Int           @default(0)
  lastStrikeAt         DateTime?
  
  // Verification
  profileVerified      Boolean       @default(false)
  photoVerified        Boolean       @default(false)
  verifiedAt           DateTime?
  
  // Rate Limiting (JSON for flexibility)
  rateLimits           Json?

  // College & Religion Scope
  collegeName String?
  collegeSlug String?
  religionKey String?

  // Preferences (JSON)
  notificationPrefs Json? // pushEnabled, etc.
  privacyPrefs      Json? // showOnlineStatus, etc.

  // Push Tokens
  pushTokens String[]

  // Two Factor
  twoFactorEnabled     Boolean  @default(false)
  twoFactorSecret      String?
  twoFactorBackupCodes String[]

  // Relations
  memberships    Member[]
  messages       Message[]       @relation("UserMessages")
  reactions      Reaction[]
  directMessagesFrom DirectMessage[] @relation("DMFrom")
  directMessagesTo   DirectMessage[] @relation("DMTo")
  dmReactions    DirectMessageReaction[]
  
  // Dating
  hasDatingProfile Boolean        @default(false)
  datingProfile    DatingProfile?

  // Reporting & Safety
  reportsMade      Report[]      @relation("Reporter")
  reportsAgainst   Report[]      @relation("Reported")
  strikes          Strike[]
  appeals          Appeal[]
  photoReports     PhotoReport[] @relation("PhotoReporter")
  moderationLogs   ModerationLog[] @relation("ModeratorActions")
  verificationRequests VerificationRequest[]

  @@map("users")
}

enum Role {
  user
  mod
  admin
}

enum AccountStatus {
  ACTIVE
  SUSPENDED
  BANNED
  UNDER_REVIEW
  DEACTIVATED
}

// ───────────────────────── Metadata / Directory ─────────────────────────
model College {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  name         String   @unique
  key          String   @unique // qc, baruch
  emailDomains String[] 
  
  // Link to the community chat
  communityId String
  community   Community @relation(fields: [communityId], references: [id])

  @@index([emailDomains])
  @@map("colleges")
}

// ───────────────────────── Community ─────────────────────────
model Community {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  name        String
  type        CommunityType @default(custom) // college, religion, custom
  key         String? // Stable identifier
  slug        String? @unique
  description String?
  isPrivate   Boolean @default(false)
  tags        String[]

  createdBy   String? // ID of creator (optional)

  // Relations
  members  Member[]
  messages Message[]
  colleges College[]

  @@index([type, key])
  @@map("communities")
}

enum CommunityType {
  college
  religion
  custom
}

// ───────────────────────── Member (Join table) ─────────────────────────
model Member {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userId      String
  communityId String

  // Profile overrides
  name   String // Display name in this community
  avatar String @default("/default-avatar.png")

  role         MemberRole   @default(member)
  memberStatus MemberStatus @default(active)

  // Token
  fcmToken String?

  // Relations
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  community Community @relation(fields: [communityId], references: [id], onDelete: Cascade)

  @@unique([userId, communityId]) // One membership per user per community
  @@index([userId, memberStatus]) // CRITICAL: Speed up "my communities" query
  @@index([communityId, memberStatus])
  @@map("members")
}

enum MemberRole {
  member
  admin
  owner
}

enum MemberStatus {
  active
  invited
  banned
  online // Legacy?
  owner // Legacy?
}

// ───────────────────────── Messages (Community) ─────────────────────────
model Message {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  content     String
  attachments Json? // Array of { url, type, name, size }

  // Meta
  clientMessageId String?
  status          MessageStatus @default(sent)
  isDeleted       Boolean       @default(false)
  deletedAt       DateTime?
  editedAt        DateTime?
  deliveredAt     DateTime?
  readAt          DateTime?

  // Sender info (snapshot)
  senderName String // Captured at send time

  // Relations
  senderId    String
  communityId String
  
  sender    User      @relation("UserMessages", fields: [senderId], references: [id], onDelete: Cascade)
  community Community @relation(fields: [communityId], references: [id], onDelete: Cascade)

  // Reply
  replyToId   String?
  replyTo     Message?  @relation("ReplyTo", fields: [replyToId], references: [id])
  replies     Message[] @relation("ReplyTo")
  
  // Reply snapshot (for performance/simplicity, as per Mongo schema)
  replyToSnapshot Json? // { messageId, sender, content }

  reactions Reaction[]

  @@index([communityId, createdAt(sort: Desc)])
  @@map("messages")
}

enum MessageStatus {
  sent
  delivered
  read
  edited
  deleted
}

model Reaction {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  emoji String

  messageId String
  userId    String
  
  message Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("reactions")
}

// ───────────────────────── Direct Messages ─────────────────────────
model DirectMessage {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  content     String?
  type        DMType  @default(text)
  context     String  @default("community") // "community" or "dating"
  attachments Json?

  status      MessageStatus @default(sent)
  isDeleted   Boolean       @default(false)
  deletedAt   DateTime?
  editedAt    DateTime?
  deliveredAt DateTime?
  readAt      DateTime?

  fromId String
  toId   String

  from User @relation("DMFrom", fields: [fromId], references: [id], onDelete: Cascade)
  to   User @relation("DMTo", fields: [toId], references: [id], onDelete: Cascade)

  reactions DirectMessageReaction[]

  @@index([fromId, toId, createdAt])
  @@map("direct_messages")
}

enum DMType {
  text
  photo
  video
  audio
  file
}

model DirectMessageReaction {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  emoji String

  dmId   String
  userId String
  
  dm     DirectMessage @relation(fields: [dmId], references: [id], onDelete: Cascade)
  user   User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("dm_reactions")
}

// ───────────────────────── Dating ─────────────────────────
// ───────────────────────── Dating Feature Schema ─────────────────────────

// Enhanced Dating Profile
model DatingProfile {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // ── Connection to Core User ──
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // ── Identity & Bio ──
  firstName   String   // Real first name (Required)
  birthDate   DateTime // For age calculation (Required 18+)
  gender      Gender
  bio         String?  @db.VarChar(500)
  height      Int?     // In cm or inches (storage normalized)
  
  // ── College/Education (CUNY context) ──
  collegeSlug String   // e.g., 'baruch', 'hunter'
  major       String?
  year        StudyYear? // Freshman, Sophomore, etc.

  // ── Details ──
  lookingFor      LookingFor[] // Relationship, Casual, etc.
  hobbies         String[]     // Tags: "Gym", "Music", "Coding"
  instagramHandle String?      // For verification/display

  // ── Location ──
  // We can store lat/long for distance calculation
  latitude  Float?
  longitude Float?
  
  // ── Status & Verification ──
  isProfileVisible  Boolean   @default(true) // "Show me on dating"
  isPaused          Boolean   @default(false)
  
  isPhotoVerified   Boolean   @default(false) // Blue tick?
  photoVerifiedAt   DateTime?
  
  approvalStatus    ApprovalStatus @default(PENDING) // Manual/AI approval of text/bio
  rejectionReason   String?

  score             Float     @default(0) // Profile completeness score

  // ── Relations ──
  photos      DatingPhoto[]
  preference  DatingPreference?
  
  swipesMade    DatingSwipe[] @relation("Swiper")
  swipesReceived DatingSwipe[] @relation("Target")
  
  matches1    DatingMatch[] @relation("MatchProfile1")
  matches2    DatingMatch[] @relation("MatchProfile2")
  
  blocksGiven    DatingBlock[] @relation("Blocker")
  blocksReceived DatingBlock[] @relation("Blocked")

  @@index([collegeSlug])
  @@index([gender])
  @@index([userId])
  @@map("dating_profiles")
}

// Dating Preferences (Filters)
model DatingPreference {
  id        String   @id @default(cuid())
  
  datingProfileId String @unique
  datingProfile   DatingProfile @relation(fields: [datingProfileId], references: [id], onDelete: Cascade)

  // Filters
  ageMin       Int @default(18)
  ageMax       Int @default(30)
  
  maxDistance  Int @default(50) // in km/miles
  
  interestedInGender Gender[] // Array of genders interested in
  
  preferredColleges  String[] // Array of college slugs (or empty for all)
  
  // Privacy
  showToPeopleOnCampusOnly Boolean @default(false)
  isDistanceVisible        Boolean @default(true)
  isCollegeVisible         Boolean @default(true)

  @@map("dating_preferences")
}

// Photos with Moderation
model DatingPhoto {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  datingProfileId String
  datingProfile   DatingProfile @relation(fields: [datingProfileId], references: [id], onDelete: Cascade)

  url       String
  thumbnail String?
  order     Int      @default(0)
  
  status          PhotoStatus @default(PENDING)
  rejectionReason String?
  reviewedBy      String?  // Admin user ID
  reviewedAt      DateTime?
  
  // AI placeholders (for future)
  aiFlags         Json?
  
  isMain    Boolean     @default(false)
  
  reports   PhotoReport[]

  @@index([datingProfileId])
  @@index([status])
  @@map("dating_photos")
}

// The "Swipe" Action
model DatingSwipe {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  swiperId String
  swiper   DatingProfile @relation("Swiper", fields: [swiperId], references: [id], onDelete: Cascade)

  targetId String
  target   DatingProfile @relation("Target", fields: [targetId], references: [id], onDelete: Cascade)

  type     SwipeType // LIKE, DISLIKE, SUPERLIKE

  @@unique([swiperId, targetId]) // Can only swipe once per person
  @@index([swiperId])
  @@index([targetId])
  @@map("dating_swipes")
}

// Successful Match
model DatingMatch {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt // Last activity

  // Determine Profile1 < Profile2 by ID sorts to ensure uniqueness constraint
  profile1Id String
  profile1   DatingProfile @relation("MatchProfile1", fields: [profile1Id], references: [id], onDelete: Cascade)

  profile2Id String
  profile2   DatingProfile @relation("MatchProfile2", fields: [profile2Id], references: [id], onDelete: Cascade)

  isActive   Boolean @default(true) // becomes false if unmatched
  unmatchedBy String? // ID of who unmatched
  
  // Link to a conversation/thread
  channelId String? 

  @@unique([profile1Id, profile2Id])
  @@index([profile1Id])
  @@index([profile2Id])
  @@map("dating_matches")
}

// Enums
enum Gender {
  MALE
  FEMALE
  NON_BINARY
  OTHER
}

enum LookingFor {
  RELATIONSHIP
  CASUAL
  FRIENDS
  UNSURE
}

enum StudyYear {
  FRESHMAN
  SOPHOMORE
  JUNIOR
  SENIOR
  GRADUATE
  ALUMNI
  OTHER
}

enum ApprovalStatus {
  PENDING
  APPROVED
  REJECTED
  NEEDS_CHANGES
}

enum PhotoStatus {
  PENDING
  APPROVED
  REJECTED
}

enum SwipeType {
  LIKE
  DISLIKE
  SUPERLIKE
}

// ───────────────────────── Reports ─────────────────────────
model Report {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Reporter
  reporterId String
  reporter   User   @relation("Reporter", fields: [reporterId], references: [id])

  // Reported User
  reportedId String
  reported   User   @relation("Reported", fields: [reportedId], references: [id])
  
  // Report Details
  reason       ReportReason
  category     String?      // Subcategory
  details      String?
  targetType   String       // "profile", "photo", "message", "behavior"
  targetId     String?
  
  // Evidence
  screenshots  String[]     // URLs to uploaded screenshots
  
  // Status
  status       ReportStatus   @default(PENDING)
  priority     ReportPriority @default(NORMAL)
  
  // Review
  reviewedBy   String?
  reviewedAt   DateTime?
  reviewNotes  String?
  actionTaken  String?      // "warning", "strike", "suspend", "ban", "dismissed"
  
  @@index([reportedId, status])
  @@index([status, priority])
  @@index([createdAt])
  @@map("reports")
}

enum ReportReason {
  HARASSMENT
  FAKE_PROFILE
  INAPPROPRIATE_CONTENT
  SAFETY_CONCERN
  SPAM
  UNDERAGE
  HATE_SPEECH
  IMPERSONATION
  OTHER
}

enum ReportStatus {
  PENDING
  UNDER_REVIEW
  RESOLVED
  DISMISSED
}

enum ReportPriority {
  LOW
  NORMAL
  HIGH
  URGENT
}

// Blocking
model DatingBlock {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  blockerId String
  blocker   DatingProfile @relation("Blocker", fields: [blockerId], references: [id], onDelete: Cascade)

  blockedId String
  blocked   DatingProfile @relation("Blocked", fields: [blockedId], references: [id], onDelete: Cascade)

  @@unique([blockerId, blockedId])
  @@index([blockerId])
  @@index([blockedId])
  @@map("dating_blocks")
}

// ───────────────────────── Verification ─────────────────────────
model VerificationRequest {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  
  poseId    String
  pose      VerificationPose @relation(fields: [poseId], references: [id])
  photoUrl  String   // The selfie they took
  
  status    ApprovalStatus @default(PENDING)
  adminNote String?
  
  reviewedBy String? // Admin ID
  reviewedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([status])
  @@map("verification_requests")
}

model VerificationPose {
  id          String @id @default(cuid())
  name        String // e.g. "Peace Sign"
  instruction String // "Hold up two fingers like a peace sign"
  referenceImageUrl String 
  isActive    Boolean @default(true)
  
  requests    VerificationRequest[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("verification_poses")
}

// ───────────────────────── Photo Reports ─────────────────────────
model PhotoReport {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  
  reporterId String
  reporter   User @relation("PhotoReporter", fields: [reporterId], references: [id])
  
  photoId    String
  photo      DatingPhoto @relation(fields: [photoId], references: [id], onDelete: Cascade)
  
  reason     PhotoReportReason
  details    String?
  status     ReportStatus @default(PENDING)
  
  reviewedBy String?
  reviewedAt DateTime?
  
  @@index([photoId, status])
  @@map("photo_reports")
}

enum PhotoReportReason {
  NUDITY
  NOT_REAL_PERSON
  SOMEONE_ELSE
  INAPPROPRIATE
  CELEBRITY_STOCK
  OTHER
}

// ───────────────────────── Strikes ─────────────────────────
model Strike {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  
  userId    String
  user      User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  reason    String
  severity  StrikeSeverity @default(MINOR)
  details   String?
  
  // Linked to report/incident
  reportId  String?
  
  // Issued by
  issuedBy  String  // Admin user ID
  
  // Expiration (strikes can expire after X months)
  expiresAt DateTime?
  active    Boolean @default(true)
  
  @@index([userId, active])
  @@index([createdAt])
  @@map("strikes")
}

enum StrikeSeverity {
  MINOR    // Warning
  MODERATE // Temporary suspension
  SEVERE   // Long suspension or ban consideration
}

// ───────────────────────── Appeals ─────────────────────────
model Appeal {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  userId    String
  user      User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // What they're appealing
  type      AppealType
  strikeId  String?
  reportId  String?
  
  reason    String
  status    AppealStatus @default(PENDING)
  
  // Review
  reviewedBy   String?
  reviewedAt   DateTime?
  reviewNotes  String?
  decision     String?  // "approved", "denied", "partial"
  
  @@index([userId, status])
  @@index([status])
  @@map("appeals")
}

enum AppealType {
  STRIKE
  SUSPENSION
  BAN
  PHOTO_REJECTION
}

enum AppealStatus {
  PENDING
  UNDER_REVIEW
  APPROVED
  DENIED
}

// ───────────────────────── Moderation Logs ─────────────────────────
model ModerationLog {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  
  // What happened
  action       String   // "photo_approved", "user_banned", "report_reviewed", etc.
  targetType   String   // "user", "photo", "report"
  targetId     String
  
  // Who did it
  moderatorId  String
  moderator    User @relation("ModeratorActions", fields: [moderatorId], references: [id])
  
  // Context
  reason       String?
  details      Json?
  
  // Link to related entities
  userId       String?
  reportId     String?
  strikeId     String?
  
  @@index([targetType, targetId])
  @@index([moderatorId])
  @@index([createdAt])
  @@map("moderation_logs")
}
